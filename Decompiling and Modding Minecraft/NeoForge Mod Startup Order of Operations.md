# Order of Operations

I realized while reading the `Config.java` and `ExampleMod.java` files that to successfully add 1) an unnamed item, 2) an unnamed block, and 3) a Creative Mode Inventory Tab containing one or both of the previous, a huge number of things must occur in the Constructor of the `ExampleMod.java`. While this is not a comprehensive list of all things that exist in the two files, this is a key section of information. The other primary thing I need to wrap my head around at this time is the `ModConfigSpec`, which I would understand to be a mod-wise register of everything that exists in the mod for organization and configuration purposes.

1. Add the method `commonSetup()` to the NeoForge `modEventBus`. I would understand this to be an example of the Event/EventListener pattern that I learned in relation to other gamedev engines.
2. Register the previously created Blocks, Items, and Creative Mode Inventotry Tab to the `modEventBus`.
3. In the case that the implemented class has functions annotated with `@SubscriberEvent` (ie, is listening for events), register the instance of the mod class with the NeoForge Event Bus.
4. Register Items and Blocks to the mod's Creative Mode Tab (note: the example Mod places the item in the custom tab, while the block goes into building blocks, likely to show an interested developer the difference.)
5. Register the Mod with NeoForge so that the mod and it's config file can be loaded by NeoForge.



Inside of the Config Class a number of other things happen. The following is based on the tutorial, any may not fully express the usefulness of all included elements.

The key repeated idea is the ModConfigSpec, which seems to allow the creation of specifications for what data the mod needs. I would understand objects of this class to then be metadata that the mod needs to function internally. For a mod like Create, this might be things like maximum rotation speed of any rotating part, the amount of stress taken up by each machine, or the minimum rotation speed necessary for the mixer to function. The below list of steps describe the included ModConfigSpec values in order and what happens to them.

1. At runtime, the Config class for the mod creates a `private static` field called `ModConfigSpec.Builder BUILDER` (line 29 atm). I would understand this to be a sort of registry (without being a Minecraft Game Registry) for all meta data that the mod needs to keep track of, including configuration data and resource paths. I am unsure at this time how data that is world specific is stored, though I would understand player specific data is associated with another, Client-related, class.

2. Next the class creates a `ModConfigSpec.BooleanValue LOG_DIRT_BLOCK`, which I would understand to be a simple boolean flag that is then associated with the mod. In this case, the comment implies that the value used should toggle whether "the dirt block" is logged on common setup, though I see no functionaliy expressed suffecient to do so. Note should be made here that at creation, there is a `.comment()` method, allowing a programmer to add a note to the value itself, which can presumably be called for to make clear what the value is doing. I would encourage myself and any potential others who are reading this to always include a comment associated with an MCS for clarity. In a non-tutorial mod, a boolean flag like this one would likely be used to create a toggle for a behavior that the mod can do, but doesn't always need to, like the "Do a Barrel Roll" mod applying changes to Elytra movement. In the tutorial mod, the creation of this flag also calls `.define()`. While I am not totally clear on the functioning of this behavior, the method is given a `path` value, which I suspect is the flag name in the config when viewed through the Mod Options page from the main menu, though I am not certain of this. Second, the call accepts a `defaultValue` which is true, which would explain the mention of "dirt block" I have seen in the game log on start up.

3. Next, the class creates `ModConfigSpec.IntValue MAGIC_NUMBER`. This is similar to the previous, in that a explanitory comment is applied. Instead of `.define()` being called next, `.defineInRange()` is called next. This method still supplies a `path` and `defaultValue` parameters, but then supplies a `min` (presumably a minimum value for the IntValue), and a `max`, which the tutorial assigns to the Integer maximum.
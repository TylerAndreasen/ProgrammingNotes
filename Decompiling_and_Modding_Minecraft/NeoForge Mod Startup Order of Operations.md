# Start Up Order of Operations

I realized while reading the `Config.java` and `ExampleMod.java` files that to successfully add 1) an unnamed item, 2) an unnamed block, and 3) a Creative Mode Inventory Tab containing one or both of the previous, a huge number of things must occur in the Constructor of the `ExampleMod.java`. While this is not a comprehensive list of all things that exist in the two files, this is a key section of information. The other primary thing I need to wrap my head around at this time is the `ModConfigSpec`, which I would understand to be a mod-wise register of everything that exists in the mod for organization and configuration purposes. Several objects within the class act as builders for mod objects, which information is passed to to create meaningful objects.

1. Add the method `commonSetup()` to the NeoForge `modEventBus`. I would understand this to be an example of the Event/EventListener pattern that I learned in relation to other gamedev engines.
2. Register the previously created Blocks, Items, and Creative Mode Inventotry Tab to the `modEventBus`.
3. In the case that the implemented class has functions annotated with `@SubscriberEvent` (ie, is listening for events), register the instance of the mod class with the NeoForge Event Bus.
4. Register Items and Blocks to the mod's Creative Mode Tab (note: the example Mod places the item in the custom tab, while the block goes into building blocks, likely to show an interested developer the difference.)
5. Register the Mod with NeoForge so that the mod and it's config file can be loaded by NeoForge.



Inside of the Config Class a number of other things happen. The following is based on the tutorial, any may not fully express the usefulness of all included elements.

The key repeated idea is the ModConfigSpec, which seems to allow the creation of specifications for what data the mod needs. I would understand objects of this class to then be metadata that the mod needs to function internally. For a mod like Create, this might be things like maximum rotation speed of any rotating part, the amount of stress taken up by each machine, or the minimum rotation speed necessary for the Mechanical Mixer to function. The below list of steps describe the included ModConfigSpec values in order and what happens to them.

Question: Does it make sense to automate the process of registering many blocks with a loop? In the case that a mod implements many decorative blocks that have no functionaliy, it may be much cleaner to setup a special resource file that lists out the reference names of all blocks, and use that to generate the objects on start up. For blocks with more sophistocated functionality, I suspect there will be enough other requirements that that approach isn't highly viable or useful.

1. At runtime, the Config class for the mod creates a `private static` field called `ModConfigSpec.Builder BUILDER` (line 29 atm). I would understand this to be a sort of registry (without being a Minecraft Game Registry) for all meta data that the mod needs to keep track of, including configuration data and resource paths. I am unsure at this time how data that is world specific is stored, though I would understand player specific data is associated with another, Client-related, class. How I hook in via NeoForge I am also unsure. 

2. Next the declaration creates a `ModConfigSpec.BooleanValue LOG_DIRT_BLOCK`, which I would understand to be a simple boolean flag that is then associated with the mod. In this case, the comment implies that the value used should toggle whether "the dirt block" is logged on common setup, though I see no functionaliy expressed suffecient to do so. Note should be made here that at creation, there is a `.comment()` method, allowing a programmer to add a note to the value itself, which can presumably be called for to make clear what the value is doing. I would encourage myself and any potential others who are reading this to always include a comment associated with an MCS for clarity. In a non-tutorial mod, a boolean flag like this one would likely be used to create a toggle for a behavior that the mod can do, but doesn't always need to, like the "Do a Barrel Roll" mod applying changes to Elytra movement. In the tutorial mod, the creation of this flag also calls `.define()`. While I am not totally clear on the functioning of this behavior, the method is given a `path` value, which I suspect is the flag name in the config when viewed through the Mod Options page from the main menu, though I am not certain of this. Second, the call accepts a `defaultValue` which is true, which would explain the mention of "dirt block" I have seen in the game log on start up. I am unclear as I am yet to test this, but it may be the case that simply setting the flag to true is what logs the diret block message in the game log.

3. Next, the declaration creates `ModConfigSpec.IntValue MAGIC_NUMBER`. This is similar to the previous, in that a explanitory comment is applied. Instead of `.define()` being called next, `.defineInRange()` is called next. This method still supplies a `path` and `defaultValue` parameters, but then supplies a `min` (presumably a minimum value for the IntValue), and a `max`, which the tutorial assigns to the Integer maximum.

4. This element logically breaks the intuition I have been building about the nature of ModConfigSpecs. The Fourth MCS created is of the type `ModConfigSpec.ConfigValue<String>`, leaning on Java Generics to implement a `String` as config value. I mentioned that this breaks how I understood an MCS because there is no real meaning to giving a player a Mod Option that is a string without it being a list of options to choose from, which is not what this is.

5. The last individual MCS stores a list of references to `Strings` which are to be used as Item Names. I realize now that this list should probably list the items that I am including in the mod if the methods are to have the intended effect. (See 8 & 9). 

6. The final declaration of an MCS ties everything previous together. The last declaration is a ModConfigSpec (which will contain all of the values previously discussed), and is created by calling `BUILDER.build()`. I would understand this pattern to be akin to my Directory/Directory(Precursor) design, but involving creating data dynamically and finally building it when ready. Making this comparison 1) makes me question the design pattern, and 2) also makes me realize that I should give myself more credit for building a system in the way I did as this is similar though more advanced.

7. Once the MCS is finalized, the code declares static variables with names matching the above but in camelCase, along side an `Set<Item>` which is used to store a list of items for the mod. There is no `Set<Block>` which I find slightly strange, but is not massively concerning at this time. 

8. The first method in the `Config.java` is the `validateItemName()`. This I take to essentially be boiler plate code that should be in every Config, which ensures that the names of the items in the set are contained in the listing of items for the mod in the files contained within the `resources/assets/[modname]/...`. There are several of these files with differing purposes.

9. The other method in the example class is the `onLoad()` method. This is called by the FML when the mod should be ready to load. By the time this occurs the `ModConfigSpec SPEC` is already in memory, and the static variables listed in step 7 can be filled with the appropriate values from the respecitve MCS_s. Also in this method `validateItemName()` is called on every element of the list of item names to validate their presence in the resource files. Properly implementing this earlier probably would have made debugging texture issues faster.